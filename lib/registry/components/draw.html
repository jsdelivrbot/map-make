<template id="drawtemplate">
  <div id="drawtools">
    <label>Draw/modify &nbsp;</label>
    <select id="drawtype">
      <option value="navigate">Navigate</option>
      <option value="point">Draw point</option>
      <option value="ls">Draw lineString</option>
      <option value="poly">Draw polygon</option>
      <option value="modify">Modify</option>
      <option value="deleet">Delete</option>
    </select>
    <button id="serialise">Serialise drawn features</button>
    <textarea cols="40" rows="5" id="serialOP"></textarea>
    <button id="clear">Clear drawn features</button>
  </div>
</template>

<template id="popuptemplate">
  <div id="featureform">
  <label>Id</label><input type="text" size="5" id="featureid">
  <label>Title</label><input type="text" size="5" id="featuretitle">
  <button id="featurebutton">Write</button>
  </div>
</template>

<style>
  #featureform {
    background-color: white;
    padding: 1px;
    border: solid black;
  }
</style>

<script type="module">
  var ol = require('ol');
  var map = require('olMap').get();
  var utils = require('utils');
  var $ = utils.$;
  // make sure toolbar initialised
  var toolbar = require('components/toolbar');

  // add adddrawtemplate to toolbar
  $('#widgets-content').appendChild(utils.importTemplate('draw'));

  var vectors = require('vectors');

  // add a vector layer/source
  vectors.add({vectors: [{id: 'Drawn'}]}); // FIXME English
  var source = vectors.getLayers().item(vectors.getLayers().getLength()-1)
      .getSource();

  // create and add draw/modify interactions
  // select restricted to vector layers; used by modify and delete
  var select = new ol.interaction.Select({
    layers: vectors.getLayers().getArray()
  });
  map.addInteraction(select);
  var features = select.getFeatures();
  var interactions = {
    point: new ol.interaction.Draw({
      source: source,
      type: 'Point'
    }),
    ls: new ol.interaction.Draw({
      source: source,
      type: 'LineString'
    }),
    poly: new ol.interaction.Draw({
      source: source,
      type: 'Polygon'
    }),
    modify: new ol.interaction.Modify({
      features: features
    })
  };

  toolbar.appendChild(utils.importTemplate('draw', 'popup'));
  var overlay = new ol.Overlay({
    element: $('#featureform'),
    positioning: 'bottom-center',
    stopEvent: true
  });
  map.addOverlay(overlay);

  var endCallback = function(e) {
    var el = overlay.getElement();
    el.style.display = 'block';
    // FIXME change to pixel from event when available from ol
    overlay.setPosition(e.feature.getGeometry().getFirstCoordinate());
    $('#featurebutton').addEventListener('click', function() {
      // FIXME create attributes properly
      e.feature.set('id', $('#featureid').value);
      e.feature.set('title', $('#featuretitle').value);
      el.style.display = 'none';
    });
  };

  interactions.point.on('drawend', endCallback);
  interactions.ls.on('drawend', endCallback);
  interactions.poly.on('drawend', endCallback);

  var i;
  // interactions inactive until clicked
  for (i in interactions) {
    map.addInteraction(interactions[i]);
    interactions[i].setActive(false);
  }

  var wasDelete = false, evtKey;
  $('#drawtype').onchange = function(e) {
    // set any previously active interactions inactive
    for (i in interactions) {
      interactions[i].setActive(false);
    }
    // ... and clicked one active
    if (interactions[e.target.value]) {
      interactions[e.target.value].setActive(true);
    }
    // if delete, add listener to delete from source and select when selected
    if (e.target.value == 'deleet') {
      evtKey = features.on('add', function(e) {
        vectors.getLayers().forEach(function(l) {
          var srce = l.getSource();
          if (e.element.getId()) {
            if (srce.getFeatureById(e.element.getId())) {
              srce.removeFeature(e.element);
            }
          } else {
            srce.getFeatures().some(function(f) {
              if (f == e.element) {
                srce.removeFeature(e.element);
              }
            });
          }
        });
        features.clear();
      });
      wasDelete = true;
    } else if (wasDelete) {
      ol.Observable.unByKey(evtKey);
      wasDelete = false;
    }
  };

  $('#adddraw').style.display = 'none';

  var op = $('#serialOP');
  $('#serialise').addEventListener('click', function() {
    var gj = new ol.format.GeoJSON();
    op.value =
        gj.writeFeatures(source.getFeatures(), {
          featureProjection: map.getView().getProjection()
        });
  });
  $('#clear').addEventListener('click', function() {
    source.clear();
  });

  var mapDef = require('mapDef').get();
  mapDef.components = mapDef.components || {};
  mapDef.components.draw = true;
</script>
